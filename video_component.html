<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¿®ç·´éŠæˆ² - å½±ç‰‡å…ƒä»¶</title>
    
    <!-- Twitch Extensions SDK -->
    <script src="https://extension-files.twitch.tv/helper/v1/twitch-ext.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', sans-serif;
            background: transparent;
            color: #efeff1;
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            user-select: none;
            font-size: clamp(14px, 2vw, 24px);
        }

        /* ä¸»å®¹å™¨ */
        .game-panel {
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            border: none;
            box-shadow: none;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .game-panel.minimized {
            height: clamp(50px, 8vh, 80px);
            overflow: hidden;
        }

        /* é ­éƒ¨ */
        .panel-header {
            background: rgba(145, 70, 255, 0.9);
            padding: clamp(15px, 3vh, 25px) clamp(20px, 4vw, 40px);
            border-radius: 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            flex-shrink: 0;
        }

        .panel-title {
            font-size: clamp(1.5rem, 4vw, 3rem);
            font-weight: 700;
            color: #fff;
            display: flex;
            align-items: center;
            gap: clamp(8px, 1vw, 16px);
        }

        .minimize-btn {
            background: none;
            border: none;
            color: #fff;
            font-size: clamp(1.2rem, 3vw, 2rem);
            cursor: pointer;
            padding: clamp(6px, 1vh, 12px) clamp(8px, 1vw, 16px);
            border-radius: 6px;
            transition: background 0.2s ease;
            font-weight: bold;
        }

        .minimize-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* å…§å®¹å€åŸŸ */
        .panel-content {
            padding: clamp(20px, 4vw, 50px);
            flex: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: clamp(20px, 3vh, 40px);
        }

        /* ç©å®¶ç‹€æ…‹å€åŸŸ */
        .player-section {
            padding-bottom: clamp(15px, 3vh, 30px);
            border-bottom: 2px solid rgba(255, 255, 255, 0.15);
            flex-shrink: 0;
        }

        .player-info {
            text-align: center;
        }

        .player-name {
            font-size: clamp(1.8rem, 5vw, 4rem);
            font-weight: 700;
            color: #ffd700;
            margin-bottom: clamp(8px, 2vh, 16px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
        }

        .player-realm {
            font-size: clamp(1.2rem, 3vw, 2.5rem);
            color: #b9a3e3;
            margin-bottom: clamp(15px, 3vh, 25px);
            font-weight: 600;
        }

        .exp-bar {
            position: relative;
            width: 100%;
            height: clamp(25px, 4vh, 50px);
            background: rgba(255, 255, 255, 0.2);
            border-radius: clamp(10px, 2vh, 25px);
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .exp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4caf50, #8bc34a);
            border-radius: 10px;
            transition: width 0.5s ease;
            position: relative;
        }

        .exp-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        .exp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: clamp(1rem, 2.5vw, 2rem);
            font-weight: 700;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        /* éŠæˆ²æ•¸å€¼å€åŸŸ */
        .stats-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }

        .section-title {
            font-size: clamp(1.4rem, 4vw, 3rem);
            font-weight: 700;
            color: #ffd700;
            margin-bottom: clamp(12px, 2vh, 20px);
            display: flex;
            align-items: center;
            gap: clamp(8px, 1vw, 16px);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
            flex-shrink: 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(clamp(120px, 20vw, 200px), 1fr));
            gap: clamp(10px, 2vh, 20px);
            flex: 1;
            overflow-y: auto;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: clamp(12px, 2vh, 20px);
            background: rgba(255, 255, 255, 0.08);
            border-radius: clamp(8px, 1vh, 15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.2s ease;
            min-height: clamp(60px, 8vh, 100px);
            text-align: center;
        }

        .leaderboard-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .stat-label {
            font-size: clamp(0.7rem, 1.5vw, 1.1rem);
            color: #b9a3e3;
            margin-bottom: clamp(4px, 0.5vh, 8px);
            font-weight: 500;
            white-space: nowrap;
        }

        .stat-value {
            font-size: clamp(1rem, 2.5vw, 1.8rem);
            font-weight: 700;
            color: #ffd700;
            white-space: nowrap;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .stat-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-2px);
        }

        /* ä¸åŒé¡å‹æ•¸å€¼çš„é¡è‰² */
        .stat-item:nth-child(1) .stat-value { color: #4caf50; }  /* ä¿®ç·´æ¬¡æ•¸ - ç¶ è‰² */
        .stat-item:nth-child(2) .stat-value { color: #ffd700; }  /* ç¸½ç¶“é©— - é‡‘è‰² */
        .stat-item:nth-child(3) .stat-value { color: #ff6b35; }  /* çªç ´æ¬¡æ•¸ - æ©˜è‰² */
        .stat-item:nth-child(4) .stat-value { color: #00bcd4; }  /* æ•ˆç‡ - é’è‰² */
        .stat-item:nth-child(5) .stat-value { color: #9c27b0; }  /* æ™‚é–“ - ç´«è‰² */
        .stat-item:nth-child(6) .stat-value { color: #e91e63; }  /* å¢ƒç•Œ - ç²‰è‰² */

        /* ç‹€æ…‹æŒ‡ç¤ºå™¨ */
        .status-indicator {
            display: flex;
            align-items: center;
            gap: clamp(6px, 1vw, 12px);
            padding: clamp(8px, 1vh, 15px) clamp(10px, 2vw, 20px);
            background: rgba(255, 255, 255, 0.05);
            border-radius: clamp(6px, 1vh, 12px);
            font-size: clamp(0.8rem, 2vw, 1.4rem);
            flex-shrink: 0;
        }

        .status-dot {
            width: clamp(8px, 1.5vw, 15px);
            height: clamp(8px, 1.5vw, 15px);
            border-radius: 50%;
            animation: pulse 2s infinite;
            flex-shrink: 0;
        }

        .status-dot.connected {
            background: #4caf50;
        }

        .status-dot.disconnected {
            background: #f44336;
        }

        .status-text {
            color: #b9a3e3;
        }

        /* ä¿®ç·´çµæœå½ˆçª— */
        .cultivation-result {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            border-radius: clamp(8px, 1vh, 15px);
            padding: clamp(20px, 4vw, 40px);
            text-align: center;
            border: 2px solid rgba(255, 215, 0, 0.3);
            z-index: 1000;
            opacity: 0;
            scale: 0.8;
            transition: all 0.3s ease;
            pointer-events: none;
            min-width: clamp(200px, 30vw, 400px);
            max-width: 80vw;
        }

        .cultivation-result.show {
            opacity: 1;
            scale: 1;
            pointer-events: auto;
        }

        .result-icon {
            font-size: clamp(2rem, 6vw, 4rem);
            margin-bottom: clamp(8px, 2vh, 15px);
            animation: pulse 1s ease-in-out infinite;
        }

        .result-text {
            font-size: clamp(1rem, 3vw, 2rem);
            font-weight: 700;
            color: #ffd700;
            margin-bottom: clamp(6px, 1vh, 12px);
        }

        .result-details {
            font-size: clamp(0.9rem, 2.5vw, 1.5rem);
            color: #efeff1;
            white-space: pre-line;
            font-weight: 500;
        }

        /* è¼‰å…¥ç‹€æ…‹ */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 0;
            z-index: 999;
        }

        .spinner {
            width: clamp(24px, 4vw, 50px);
            height: clamp(24px, 4vw, 50px);
            border: clamp(2px, 0.5vw, 4px) solid rgba(255, 255, 255, 0.3);
            border-top: clamp(2px, 0.5vw, 4px) solid #ffd700;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: clamp(8px, 2vh, 15px);
        }

        .loading-text {
            font-size: clamp(0.9rem, 2.5vw, 1.5rem);
            color: #b9a3e3;
            font-weight: 500;
        }

        /* å‹•ç•« */
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.8; }
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        /* éŸ¿æ‡‰å¼å„ªåŒ– */
        @media (max-width: 768px) {
            .panel-content {
                gap: clamp(15px, 2vh, 25px);
            }
            
            .leaderboard-item {
                min-height: clamp(40px, 5vh, 60px);
            }
        }
        
        @media (max-height: 600px) {
            .panel-content {
                gap: clamp(10px, 1vh, 20px);
            }
            
            .player-section {
                padding-bottom: clamp(10px, 2vh, 20px);
            }
        }
    </style>
</head>
<body>
    <!-- ä¸»è¦éŠæˆ²é¢æ¿ -->
    <div class="game-panel" id="gamePanel">
        <!-- é¢æ¿é ­éƒ¨ -->
        <div class="panel-header">
            <div class="panel-title">
                ğŸ® ä¿®ç·´éŠæˆ²
            </div>
            <button class="minimize-btn" id="minimizeBtn" title="æœ€å°åŒ–/å±•é–‹">
                â”€
            </button>
        </div>

        <!-- é¢æ¿å…§å®¹ -->
        <div class="panel-content" id="panelContent">
            <!-- ç©å®¶ç‹€æ…‹å€åŸŸ -->
            <div class="player-section">
                <div class="player-info">
                    <div class="player-name" id="playerName">è¼‰å…¥ä¸­...</div>
                    <div class="player-realm" id="playerRealm">ç…‰æ°£æœŸ ç¬¬1å±¤</div>
                    <div class="exp-bar">
                        <div class="exp-fill" id="expFill" style="width: 0%"></div>
                        <div class="exp-text" id="expText">0 / 100</div>
                    </div>
                </div>
            </div>

            <!-- éŠæˆ²æ•¸å€¼å€åŸŸ -->
            <div class="stats-section">
                <div class="section-title">
                    ğŸ“Š éŠæˆ²æ•¸å€¼
                </div>
                <div class="stats-grid" id="statsGrid">
                    <div class="stat-item">
                        <div class="stat-label">ä¿®ç·´æ¬¡æ•¸</div>
                        <div class="stat-value" id="cultivationCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">ç¸½ç¶“é©—å€¼</div>
                        <div class="stat-value" id="totalExperience">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">çªç ´æ¬¡æ•¸</div>
                        <div class="stat-value" id="breakthroughCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">ä¿®ç·´æ•ˆç‡</div>
                        <div class="stat-value" id="efficiency">100%</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">åœ¨ç·šæ™‚é–“</div>
                        <div class="stat-value" id="onlineTime">0åˆ†é˜</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">ç•¶å‰å¢ƒç•Œ</div>
                        <div class="stat-value" id="currentRealm">ç…‰æ°£æœŸ</div>
                    </div>
                </div>
            </div>

            <!-- ç‹€æ…‹æŒ‡ç¤ºå™¨ -->
            <div class="status-indicator">
                <div class="status-dot" id="statusDot"></div>
                <span class="status-text" id="statusText">é€£æ¥ä¸­...</span>
            </div>
        </div>

        <!-- ä¿®ç·´çµæœå½ˆçª— -->
        <div class="cultivation-result" id="cultivationResult">
            <div class="result-icon" id="resultIcon">âš¡</div>
            <div class="result-text" id="resultText">ä¿®ç·´æˆåŠŸï¼</div>
            <div class="result-details" id="resultDetails">ç²å¾— 50 ç¶“é©—</div>
        </div>

        <!-- è¼‰å…¥è¦†è“‹å±¤ -->
        <div class="loading-overlay" id="loadingOverlay">
            <div class="spinner"></div>
            <div class="loading-text">è¼‰å…¥éŠæˆ²æ•¸æ“š...</div>
        </div>
    </div>

    <!-- JavaScript é‚è¼¯ -->
    <script>
        class CultivationVideoComponent {
            constructor() {
                this.twitch = window.Twitch ? window.Twitch.ext : null;
                this.auth = null;
                this.context = null;
                this.playerData = null;
                this.playerStats = null;
                this.isConnected = false;
                this.isMinimized = false;
                
                // API è¨­å®š
                this.apiBaseUrl = 'http://172.25.241.201:3000/api';
                this.useDatabase = true; // æ˜¯å¦ä½¿ç”¨æ•¸æ“šåº«
                
                // æ›´æ–°é–“éš”
                this.updateInterval = null;
                
                this.init();
            }

            init() {
                console.log('åˆå§‹åŒ–ä¿®ç·´éŠæˆ²å½±ç‰‡å…ƒä»¶...');
                
                if (this.twitch) {
                    this.setupTwitchCallbacks();
                } else {
                    console.log('é–‹ç™¼æ¨¡å¼ï¼šæœªæª¢æ¸¬åˆ° Twitch Extensions SDK');
                    this.initDevelopmentMode();
                }
                
                this.setupEventListeners();
                this.startUpdateCycle();
                this.startDatabaseSync();
            }

            setupTwitchCallbacks() {
                this.twitch.onAuthorized((auth) => {
                    console.log('ç”¨æˆ¶å·²æˆæ¬Š:', auth);
                    this.auth = auth;
                    this.loadPlayerData();
                });

                this.twitch.onContext((context, delta) => {
                    this.context = context;
                    this.handleContextChange(context);
                });

                this.twitch.onVisibilityChanged((isVisible) => {
                    if (isVisible) {
                        this.refreshData();
                    }
                });

                this.twitch.listen('broadcast', (target, contentType, message) => {
                    this.handleBroadcastMessage(message);
                });
            }

            initDevelopmentMode() {
                // ç”ŸæˆåŸºæ–¼ç€è¦½å™¨çš„å”¯ä¸€ç”¨æˆ¶ID
                const userId = this.generateUniqueUserId();
                
                this.auth = {
                    token: 'dev-token',
                    userId: userId,
                    channelId: 'dev-channel-456'
                };
                
                // è¨­å®šå€‹æ€§åŒ–æ•¸æ“š
                setTimeout(() => {
                    this.setPersonalizedData(userId);
                }, 1000);
            }
            
            generateUniqueUserId() {
                // æª¢æŸ¥æ˜¯å¦å·²æœ‰å„²å­˜çš„ç”¨æˆ¶ID
                let userId = localStorage.getItem('cultivation_user_id');
                
                if (!userId) {
                    // ç”Ÿæˆæ–°çš„å”¯ä¸€ID
                    userId = 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                    localStorage.setItem('cultivation_user_id', userId);
                }
                
                return userId;
            }
            
            setPersonalizedData(userId) {
                // åŸºæ–¼ç”¨æˆ¶IDç”Ÿæˆå€‹æ€§åŒ–æ•¸æ“š
                const userData = this.generateUserData(userId);
                
                this.playerData = userData.playerData;
                this.playerStats = userData.playerStats;
                
                // å„²å­˜åˆ°æœ¬åœ°å­˜å„²
                this.saveUserData();
                
                this.updatePlayerUI();
                this.updateStatsUI();
                this.setConnectionStatus(true);
                this.hideLoading();
                
                // æ·»åŠ å¯¦æ™‚æ•¸æ“šæ›´æ–°æ¨¡æ“¬
                this.startMockDataUpdates();
            }
            
            generateUserData(userId) {
                // ä½¿ç”¨ç”¨æˆ¶IDä½œç‚ºç¨®å­ç”Ÿæˆéš¨æ©Ÿæ•¸
                const seed = this.hashCode(userId);
                const random = this.seededRandom(seed);
                
                // ç”Ÿæˆå€‹æ€§åŒ–ç”¨æˆ¶å
                const usernames = [
                    'é£›å‡é“å‹', 'ä¿®çœŸè€…', 'ç…‰ä¸¹å¸«', 'åŠä»™', 'é“é•·',
                    'ä»™å‹', 'ä¸¹å¸«', 'åŠå®¢', 'é“å£«', 'ä¿®å£«',
                    'å¤©æ‰', 'å¥‡æ‰', 'ç¥ç«¥', 'é«˜æ‰‹', 'å¤§å¸«'
                ];
                const username = usernames[Math.floor(random() * usernames.length)] + Math.floor(random() * 9999);
                
                // ç”Ÿæˆå€‹æ€§åŒ–å¢ƒç•Œ
                const realms = ['ç…‰æ°£æœŸ', 'ç¯‰åŸºæœŸ', 'é‡‘ä¸¹æœŸ', 'å…ƒå¬°æœŸ', 'åŒ–ç¥æœŸ'];
                const realmIndex = Math.floor(random() * realms.length);
                const realm = realms[realmIndex];
                const level = Math.floor(random() * 9) + 1;
                
                // åŸºæ–¼å¢ƒç•Œè¨ˆç®—ç¶“é©—å€¼
                const baseExp = (realmIndex + 1) * 1000 + (level - 1) * 500;
                const experience = Math.floor(random() * 800) + 200;
                const expRequired = baseExp + Math.floor(random() * 500) + 500;
                
                // ç”Ÿæˆå€‹æ€§åŒ–çµ±è¨ˆæ•¸æ“š
                const cultivationCount = Math.floor(random() * 5000) + 1000;
                const totalExperience = Math.floor(random() * 100000) + 50000;
                const breakthroughCount = Math.floor(random() * 30) + 10;
                const efficiency = Math.floor(random() * 25) + 75;
                const onlineTime = Math.floor(random() * 500) + 100;
                
                return {
                    playerData: {
                        username: username,
                        realm: realm,
                        level: level,
                        experience: experience,
                        expRequired: expRequired
                    },
                    playerStats: {
                        cultivationCount: cultivationCount,
                        totalExperience: totalExperience,
                        breakthroughCount: breakthroughCount,
                        efficiency: efficiency,
                        onlineTime: onlineTime,
                        currentRealm: realm
                    }
                };
            }
            
            // å­—ç¬¦ä¸²å“ˆå¸Œå‡½æ•¸
            hashCode(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // è½‰æ›ç‚º32ä½æ•´æ•¸
                }
                return Math.abs(hash);
            }
            
            // åŸºæ–¼ç¨®å­çš„éš¨æ©Ÿæ•¸ç”Ÿæˆå™¨
            seededRandom(seed) {
                let current = seed;
                return function() {
                    current = (current * 1103515245 + 12345) & 0x7fffffff;
                    return current / 0x7fffffff;
                };
            }
            
            // å„²å­˜ç”¨æˆ¶æ•¸æ“šåˆ°æœ¬åœ°å­˜å„²
            saveUserData() {
                const userData = {
                    playerData: this.playerData,
                    playerStats: this.playerStats,
                    lastUpdate: Date.now()
                };
                localStorage.setItem('cultivation_user_data', JSON.stringify(userData));
            }
            
            // å¾æœ¬åœ°å­˜å„²è¼‰å…¥ç”¨æˆ¶æ•¸æ“š
            loadUserData() {
                const savedData = localStorage.getItem('cultivation_user_data');
                if (savedData) {
                    try {
                        const userData = JSON.parse(savedData);
                        
                        // æª¢æŸ¥æ•¸æ“šæ˜¯å¦éæœŸï¼ˆ7å¤©ï¼‰
                        const now = Date.now();
                        const sevenDays = 7 * 24 * 60 * 60 * 1000;
                        
                        if (now - userData.lastUpdate < sevenDays) {
                            this.playerData = userData.playerData;
                            this.playerStats = userData.playerStats;
                            return true;
                        }
                    } catch (error) {
                        console.error('è¼‰å…¥ç”¨æˆ¶æ•¸æ“šå¤±æ•—:', error);
                    }
                }
                return false;
            }
            
            setMockData() {
                // å˜—è©¦è¼‰å…¥å·²å­˜å„²çš„ç”¨æˆ¶æ•¸æ“š
                if (this.loadUserData()) {
                    this.updatePlayerUI();
                    this.updateStatsUI();
                    this.setConnectionStatus(true);
                    this.hideLoading();
                    this.startMockDataUpdates();
                    return;
                }
                
                // å¦‚æœæ²’æœ‰å„²å­˜çš„æ•¸æ“šï¼Œç”Ÿæˆæ–°çš„å€‹æ€§åŒ–æ•¸æ“š
                const userId = this.generateUniqueUserId();
                this.setPersonalizedData(userId);
            }

            setupEventListeners() {
                // æœ€å°åŒ–æŒ‰éˆ•
                document.getElementById('minimizeBtn').addEventListener('click', () => {
                    this.toggleMinimize();
                });
            }

            async loadPlayerData() {
                try {
                    this.showLoading();
                    const username = this.getUsernameFromAuth();
                    
                    if (!username) {
                        console.log('ç„¡æ³•ç²å–ç”¨æˆ¶åç¨±');
                        this.setConnectionStatus(false);
                        this.hideLoading();
                        return;
                    }

                    if (this.useDatabase) {
                        // å˜—è©¦å¾ MongoDB è¼‰å…¥æ•¸æ“š
                        const response = await this.apiRequest(`/players/${username}`);
                        
                        if (response.success) {
                            this.playerData = response.data;
                            this.updatePlayerUI();
                            this.setConnectionStatus(true);
                            this.loadPlayerStats();
                        } else {
                            console.log('å¾æ•¸æ“šåº«è¼‰å…¥å¤±æ•—ï¼Œå‰µå»ºæ–°ç©å®¶:', response.message);
                            // å‰µå»ºæ–°ç©å®¶
                            await this.createNewPlayer(username);
                        }
                    } else {
                        // ä½¿ç”¨æœ¬åœ°æ•¸æ“š
                        this.setMockData();
                    }
                    
                    this.hideLoading();
                } catch (error) {
                    console.error('è¼‰å…¥ç©å®¶æ•¸æ“šéŒ¯èª¤:', error);
                    console.log('åˆ‡æ›åˆ°æœ¬åœ°æ¨¡å¼');
                    this.useDatabase = false;
                    this.setMockData();
                    this.hideLoading();
                }
            }

            async createNewPlayer(username) {
                try {
                    const newPlayerData = {
                        username: username,
                        realm: 'ç…‰æ°£æœŸ',
                        level: 1,
                        experience: 0,
                        expRequired: 100,
                        stats: {
                            cultivationCount: 0,
                            totalExperience: 0,
                            breakthroughCount: 0,
                            efficiency: 100,
                            onlineTime: 0,
                            currentRealm: 'ç…‰æ°£æœŸ'
                        }
                    };
                    
                    const response = await this.apiRequest('/players', {
                        method: 'POST',
                        body: JSON.stringify(newPlayerData)
                    });
                    
                    if (response.success) {
                        this.playerData = response.data;
                        this.playerStats = response.data.stats;
                        this.updatePlayerUI();
                        this.updateStatsUI();
                        this.setConnectionStatus(true);
                        console.log('æ–°ç©å®¶å‰µå»ºæˆåŠŸ');
                    } else {
                        throw new Error('å‰µå»ºæ–°ç©å®¶å¤±æ•—');
                    }
                } catch (error) {
                    console.error('å‰µå»ºæ–°ç©å®¶éŒ¯èª¤:', error);
                    this.useDatabase = false;
                    this.setMockData();
                }
            }

            async loadPlayerStats() {
                if (!this.useDatabase) return;
                
                try {
                    const username = this.getUsernameFromAuth();
                    const response = await this.apiRequest(`/players/${username}/stats`);
                    
                    if (response.success) {
                        this.playerStats = response.data;
                        this.updateStatsUI();
                    } else {
                        console.error('è¼‰å…¥éŠæˆ²æ•¸å€¼å¤±æ•—:', response.message);
                        this.setDefaultStats();
                    }
                } catch (error) {
                    console.error('è¼‰å…¥éŠæˆ²æ•¸å€¼éŒ¯èª¤:', error);
                    this.setDefaultStats();
                }
            }

            updatePlayerUI() {
                if (!this.playerData) return;

                const playerName = document.getElementById('playerName');
                const playerRealm = document.getElementById('playerRealm');
                const expFill = document.getElementById('expFill');
                const expText = document.getElementById('expText');

                if (playerName) {
                    playerName.textContent = this.playerData.username;
                }

                if (playerRealm) {
                    playerRealm.textContent = `${this.playerData.realm} ç¬¬${this.playerData.level}å±¤`;
                }

                if (expFill && expText) {
                    const expProgress = (this.playerData.experience / this.playerData.expRequired) * 100;
                    expFill.style.width = `${Math.min(expProgress, 100)}%`;
                    expText.textContent = `${this.playerData.experience} / ${this.playerData.expRequired}`;
                }
            }

            updateStatsUI() {
                const stats = this.playerStats || this.getDefaultStats();
                
                // æ›´æ–°å„å€‹æ•¸å€¼
                this.updateStatValue('cultivationCount', stats.cultivationCount || 0);
                this.updateStatValue('totalExperience', this.formatNumber(stats.totalExperience || 0));
                this.updateStatValue('breakthroughCount', stats.breakthroughCount || 0);
                this.updateStatValue('efficiency', `${stats.efficiency || 100}%`);
                this.updateStatValue('onlineTime', this.formatTime(stats.onlineTime || 0));
                this.updateStatValue('currentRealm', stats.currentRealm || 'ç…‰æ°£æœŸ');
            }
            
            updateStatValue(id, value) {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = value;
                }
            }
            
            setDefaultStats() {
                this.playerStats = this.getDefaultStats();
                this.updateStatsUI();
            }
            
            getDefaultStats() {
                return {
                    cultivationCount: 0,
                    totalExperience: 0,
                    breakthroughCount: 0,
                    efficiency: 100,
                    onlineTime: 0,
                    currentRealm: 'ç…‰æ°£æœŸ'
                };
            }

            showCultivationResult(result) {
                const resultElement = document.getElementById('cultivationResult');
                const resultIcon = document.getElementById('resultIcon');
                const resultText = document.getElementById('resultText');
                const resultDetails = document.getElementById('resultDetails');

                if (result.success) {
                    resultIcon.textContent = result.critical ? 'ğŸ’¥' : 'âš¡';
                    resultText.textContent = 'ä¿®ç·´æˆåŠŸï¼';
                    resultDetails.textContent = `ç²å¾— ${result.experience} ç¶“é©—`;
                    
                    if (result.levelUp) {
                        resultDetails.textContent += `\nğŸ‰ å‡ç´šåˆ° ${result.levelUp.realm} ${result.levelUp.level}å±¤ï¼`;
                    }
                } else {
                    resultIcon.textContent = 'ğŸ’”';
                    resultText.textContent = 'ä¿®ç·´å¤±æ•—';
                    resultDetails.textContent = result.message || 'ä¿®ç·´å¤±æ•—ï¼Œè«‹é‡è©¦';
                }

                resultElement.classList.add('show');
                
                setTimeout(() => {
                    resultElement.classList.remove('show');
                }, 3000);
            }

            handleBroadcastMessage(message) {
                try {
                    const data = JSON.parse(message);
                    
                    switch (data.type) {
                        case 'cultivation_result':
                            this.showCultivationResult(data.payload);
                            break;
                        case 'player_update':
                            this.playerData = data.payload;
                            this.updatePlayerUI();
                            break;
                        case 'stats_update':
                            this.playerStats = data.payload;
                            this.updateStatsUI();
                            break;
                        default:
                            console.log('æœªçŸ¥çš„å»£æ’­è¨Šæ¯é¡å‹:', data.type);
                    }
                } catch (error) {
                    console.error('è™•ç†å»£æ’­è¨Šæ¯éŒ¯èª¤:', error);
                }
            }

            toggleMinimize() {
                const gamePanel = document.getElementById('gamePanel');
                const minimizeBtn = document.getElementById('minimizeBtn');
                
                this.isMinimized = !this.isMinimized;
                
                if (this.isMinimized) {
                    gamePanel.classList.add('minimized');
                    minimizeBtn.textContent = '+';
                } else {
                    gamePanel.classList.remove('minimized');
                    minimizeBtn.textContent = 'â”€';
                }
            }

            setConnectionStatus(connected) {
                this.isConnected = connected;
                const statusDot = document.getElementById('statusDot');
                const statusText = document.getElementById('statusText');
                
                if (connected) {
                    statusDot.className = 'status-dot connected';
                    statusText.textContent = 'å·²é€£æ¥';
                } else {
                    statusDot.className = 'status-dot disconnected';
                    statusText.textContent = 'é€£æ¥å¤±æ•—';
                }
            }

            showLoading() {
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'flex';
                }
            }

            hideLoading() {
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.style.display = 'none';
                }
            }

            refreshData() {
                console.log('åˆ·æ–°æ•¸æ“š...');
                this.loadPlayerData();
            }

            startUpdateCycle() {
                // æ¯10ç§’æ›´æ–°ä¸€æ¬¡æ•¸æ“š
                this.updateInterval = setInterval(() => {
                    if (this.isConnected && !this.isMinimized) {
                        this.refreshData();
                    }
                }, 10000);
            }

            stopUpdateCycle() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                }
            }

            async apiRequest(endpoint, options = {}) {
                const url = `${this.apiBaseUrl}${endpoint}`;
                const defaultOptions = {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${this.auth ? this.auth.token : ''}`
                    },
                    timeout: 8000
                };

                try {
                    const response = await fetch(url, { ...defaultOptions, ...options });
                    return await response.json();
                } catch (error) {
                    console.error('API è«‹æ±‚å¤±æ•—:', error);
                    return { success: false, message: error.message };
                }
            }

            getUsernameFromAuth() {
                if (this.auth && this.auth.userId) {
                    return this.auth.userId;
                }
                return 'feisheng123'; // é–‹ç™¼æ¨¡å¼é»˜èªç”¨æˆ¶
            }

            formatNumber(num) {
                if (typeof num !== 'number') return '0';
                
                if (num >= 1000000) {
                    return (num / 1000000).toFixed(1) + 'M';
                } else if (num >= 1000) {
                    return (num / 1000).toFixed(1) + 'K';
                }
                return num.toString();
            }
            
            formatTime(minutes) {
                if (typeof minutes !== 'number') return '0åˆ†é˜';
                
                if (minutes >= 60) {
                    const hours = Math.floor(minutes / 60);
                    const mins = minutes % 60;
                    return `${hours}å°æ™‚${mins}åˆ†é˜`;
                }
                return `${minutes}åˆ†é˜`;
            }

            // æ¨¡æ“¬æ•¸æ“šå¯¦æ™‚æ›´æ–°
            startMockDataUpdates() {
                // æ¯5ç§’æ¨¡æ“¬ä¸€æ¬¡ä¿®ç·´çµæœ
                setInterval(() => {
                    if (Math.random() < 0.3) { // 30% æ©Ÿç‡è§¸ç™¼ä¿®ç·´çµæœ
                        this.simulateCultivationResult();
                    }
                }, 5000);
                
                // æ¯3ç§’æ›´æ–°çµ±è¨ˆæ•¸æ“š
                setInterval(() => {
                    this.updateMockStats();
                }, 3000);
            }
            
            simulateCultivationResult() {
                const results = [
                    { success: true, experience: 45, critical: false },
                    { success: true, experience: 65, critical: false },
                    { success: true, experience: 120, critical: true },
                    { success: true, experience: 85, critical: false },
                    { success: false, message: 'ä¿®ç·´å¤±æ•—ï¼Œå¿ƒå¢ƒä¸ç©©' }
                ];
                
                const result = results[Math.floor(Math.random() * results.length)];
                
                // éš¨æ©Ÿå‡ç´šäº‹ä»¶
                if (result.success && Math.random() < 0.05) {
                    result.levelUp = {
                        realm: this.playerData.realm,
                        level: this.playerData.level + 1
                    };
                }
                
                this.showCultivationResult(result);
                
                // æ›´æ–°ç©å®¶æ•¸æ“š
                if (result.success) {
                    this.playerData.experience += result.experience;
                    this.playerStats.totalExperience += result.experience;
                    this.playerStats.cultivationCount++;
                    
                    // æª¢æŸ¥æ˜¯å¦å‡ç´š
                    if (this.playerData.experience >= this.playerData.expRequired) {
                        this.playerData.level++;
                        this.playerData.experience = 0;
                        this.playerData.expRequired = Math.floor(this.playerData.expRequired * 1.5);
                        this.playerStats.breakthroughCount++;
                        
                        // å¢ƒç•Œçªç ´
                        if (this.playerData.level > 9) {
                            this.advanceRealm();
                        }
                    }
                    
                    this.updatePlayerUI();
                    this.updateStatsUI();
                    
                    // åŒæ­¥æ•¸æ“šåˆ°æ•¸æ“šåº«
                    this.syncToDatabase();
                }
            }
            
            updateMockStats() {
                // ç·©æ…¢å¢åŠ åœ¨ç·šæ™‚é–“
                this.playerStats.onlineTime++;
                
                // éš¨æ©Ÿèª¿æ•´æ•ˆç‡
                const efficiencyChange = (Math.random() - 0.5) * 2;
                this.playerStats.efficiency = Math.max(75, Math.min(100, this.playerStats.efficiency + efficiencyChange));
                
                this.updateStatsUI();
                
                // åŒæ­¥æ•¸æ“šåˆ°æ•¸æ“šåº«
                this.syncToDatabase();
            }
            
            advanceRealm() {
                const realms = [
                    'ç…‰æ°£æœŸ', 'ç¯‰åŸºæœŸ', 'é‡‘ä¸¹æœŸ', 'å…ƒå¬°æœŸ', 'åŒ–ç¥æœŸ', 
                    'ç·´è™›æœŸ', 'åˆé«”æœŸ', 'å¤§ä¹˜æœŸ', 'æ¸¡åŠ«æœŸ', 'å¤§ç¾…é‡‘ä»™'
                ];
                
                const currentIndex = realms.indexOf(this.playerData.realm);
                if (currentIndex >= 0 && currentIndex < realms.length - 1) {
                    this.playerData.realm = realms[currentIndex + 1];
                    this.playerData.level = 1;
                    this.playerStats.currentRealm = this.playerData.realm;
                    
                    // é¡¯ç¤ºçªç ´æç¤º
                    this.showCultivationResult({
                        success: true,
                        experience: 0,
                        critical: true,
                        levelUp: {
                            realm: this.playerData.realm,
                            level: 1
                        }
                    });
                }
            }

            // åŒæ­¥æ•¸æ“šåˆ°æ•¸æ“šåº«
            async syncToDatabase() {
                if (!this.useDatabase || !this.playerData) return;
                
                try {
                    const username = this.getUsernameFromAuth();
                    const updateData = {
                        realm: this.playerData.realm,
                        level: this.playerData.level,
                        experience: this.playerData.experience,
                        expRequired: this.playerData.expRequired,
                        stats: this.playerStats
                    };
                    
                    const response = await this.apiRequest(`/players/${username}`, {
                        method: 'PUT',
                        body: JSON.stringify(updateData)
                    });
                    
                    if (response.success) {
                        console.log('æ•¸æ“šå·²åŒæ­¥åˆ°æ•¸æ“šåº«');
                    } else {
                        console.error('åŒæ­¥æ•¸æ“šå¤±æ•—:', response.message);
                        // å¤±æ•—æ™‚ä¿å­˜åˆ°æœ¬åœ°å­˜å„²ä½œç‚ºå‚™ä»½
                        this.saveUserData();
                    }
                } catch (error) {
                    console.error('åŒæ­¥æ•¸æ“šéŒ¯èª¤:', error);
                    // å¤±æ•—æ™‚ä¿å­˜åˆ°æœ¬åœ°å­˜å„²ä½œç‚ºå‚™ä»½
                    this.saveUserData();
                }
            }
            
            // å®šæœŸåŒæ­¥æ•¸æ“š
            startDatabaseSync() {
                if (!this.useDatabase) return;
                
                // æ¯30ç§’åŒæ­¥ä¸€æ¬¡æ•¸æ“š
                setInterval(() => {
                    this.syncToDatabase();
                }, 30000);
            }
            
            // å¾æ•¸æ“šåº«é‡æ–°è¼‰å…¥æ•¸æ“š
            async refreshFromDatabase() {
                if (!this.useDatabase) return;
                
                try {
                    const username = this.getUsernameFromAuth();
                    const response = await this.apiRequest(`/players/${username}`);
                    
                    if (response.success) {
                        this.playerData = response.data;
                        this.playerStats = response.data.stats;
                        this.updatePlayerUI();
                        this.updateStatsUI();
                        console.log('æ•¸æ“šå·²å¾æ•¸æ“šåº«é‡æ–°è¼‰å…¥');
                    }
                } catch (error) {
                    console.error('é‡æ–°è¼‰å…¥æ•¸æ“šå¤±æ•—:', error);
                }
            }

            // æ¸…ç†è³‡æº
            destroy() {
                this.stopUpdateCycle();
                
                // æœ€å¾Œä¸€æ¬¡åŒæ­¥æ•¸æ“š
                if (this.useDatabase) {
                    this.syncToDatabase();
                }
                
                if (this.twitch) {
                    this.twitch.unlisten('broadcast', () => {});
                }
                
                console.log('å½±ç‰‡å…ƒä»¶å·²éŠ·æ¯€');
            }
        }

        // ç•¶é é¢è¼‰å…¥å®Œæˆæ™‚åˆå§‹åŒ–å…ƒä»¶
        document.addEventListener('DOMContentLoaded', () => {
            window.cultivationVideoComponent = new CultivationVideoComponent();
        });

        // ç•¶é é¢å³å°‡é—œé–‰æ™‚æ¸…ç†è³‡æº
        window.addEventListener('beforeunload', () => {
            if (window.cultivationVideoComponent) {
                window.cultivationVideoComponent.destroy();
            }
        });
    </script>
</body>
</html>